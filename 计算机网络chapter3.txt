- chapter 3 运输层
- 运输层位于应用层和网络层之间，是重要的网络体系的构成部分。我们focus在TCP和UDP两个运输层协议。
-
- 运输层的服务：两个在不同地理位置的主机能够通信，是应用了运输层的逻辑通信(logic communication)
-
- 运输层协议是在端中实现的，而不是通过路由器实现的，首先运输层会把source的massage切分成segment,每个segment都会加上运输层的header然后进行封装，然后在端系统中，运输层把这个segment传递给网络层，在destination那边，网络层会接受运输层当时封装的内容，并把封装的内容提交给运输层。
-
- 网络程序可以有多种协议，TCP和UDP就是英特网中，网络程序在运输层中的协议。
-
- 运输层和网络层的关系：网络层给主机之间提供了逻辑通信，运输层给主机上的进程之间提供了逻辑通信。
- 比如说西海岸有一个家庭A和东海岸一个家庭B进行通信，每周都会互相寄送邮件，A家庭中anna负责所有信件的寄送和接受，B海岸中bob负责所有信件的寄送和接受。这种家庭之间的相互通信可以看成是端和端的相互通信，这是基于整个邮政网络的，这个邮政网络就类似网络层。anna和bob就像是两个进程，进程之间的通信是基于端的，并且只在自己的主机中进行交互，和其他层面都没有关系。
- 两个家庭之间的通讯完全取决于网络层的服务，运输层协议is  based on 网络层。
-
- 运输层概述：因特网中的运输层协议，主要指的是TCP和UDP。TCP是传输控制协议，UDP是用户数据报协议。UDP为应用程序提供不可靠无连接的服务，TCP为应用程序提供可靠面向链接的服务。应用程序的开发人员必须指定，使用这两种协议中的哪一种
-
- 每个主机在网络层都有一个IP地址，网络层还有一个IP协议，是负责端和端之间的网际协议。IP的服务模型是尽力而为交付服务best effort delivery service
-
- TCP和UDP具体做什么事情？
- TCP和UDP具体做的事情就是将两个端系统之间的交互服务扩展到端系统之间的两个进程之间的交付服务。从主机间的交互扩展到主机上两个进程之间交互的行为叫做运输层的：多路复用(transport layer multiplexing) 和多路分解(demultiplexing)。我们会在下一章讨论运输层的多路复用和多路分解。
-
- UDP和TCP还可以提供integrity check.
-
- TCP 为应用程序提供一下服务：
- 1. 可靠数据传输reliable data transfer,可以确保正确地、按序地将数据交付给接收进城，这样不可靠的IP服务就会远程进程间可靠的数据传输服务。
	2. 拥塞控制congestion control. 这种服务与其说是提供给调用它的应用程序的服务，不如说是提供给整个英特网的服务，TCP力求为每个通过communication link的平等的共享网络带宽。

-
- 多路复用和多路分解：
- 运输层到网络层有一扇门，这个门叫做socket，信息传递的时候要通过这个门，而且传递的信息本身并不是一个完整的信息，而是套接字，每一个套接字都有唯一的标识符，标识符的格式取决于她是UDP还是TCP套接字。(接下来会讨论)
-
- 将运输成报文段中的数据交付到正确的套接字的工作叫做多路分解, demultiplexing.源主机从不同套接字中收集数据块，并为每个数据块封装上header生成报文段segment,然后将报文段传递到网络层，这些工作叫做多路复用multiplexing.
-
- 举个例子，bob拿到新建之后按照名字，分发给他的兄弟姐妹们，这个叫做多路分解。Anna把兄弟姐妹的信件手机起来，发送给邮局，这个叫做多路复用
-
- 我们看一下主机中，多路分解和多路复用是具体怎么工作的：
- 1. 套接字首先要有唯一的标识符
	2. 每个message有特殊字段来表明该message要交付到那个套接字，这些特殊字段是：source port number field 和 destination port number field
	3. 我们在开发一个新的程序的时候，必须要给它分配一个端口号。

-
- 运输层怎样进行分解服务的？
- 主机上每个套接字，分配一个端口号，message到达主机的时候，运输层检查message中的端口号，并且将其定向到相应的套接字，然后message通过套接字进入所链接的进程。 UDP基本上是这么做的。 TCP当中将会更加复杂。
-
- UDP的套接字是有两个二元组表示的，一个是目的IP地址，另一个是目的端口号，如果两个UDPmessage有不同的source IP 或者source port,但是具有相同的dest IP 和dest Port,那么这两个massage会通过相同的目的套接字定向到相同的目的进程。
-
- TCP的细微差别是： TCP的套接字是由一个四元组(source IP + source port + dest IP + dest Port)来标识的，当message到达另一台主机的时候，主机适用全部4个值将message分解到对应的套接字。如果source IP 或者source port不相同，会到达不同的套接字
-
- 无连接运输：UDP
- 如果要设计一个minimum功能的运输层，至少要讲message交给网络层，在接受一方，必须把网络层的massage交给应用，我们至少必须做一点点事情，而不是什么都不做。运输层必须提供一种复用和分解，以便在网络层和正确的应用及进程之间传递数据。这个功能几乎就是IP的功能，并且UDP在发送报文段之前，source和destination运输层实体之间没有握手，因此UDP被称为是无连接的。
-
- 既然TCP这么可靠，为啥还需要UDP呢？
- 1. 关于何时发送什么数据的应用层控制更加精细，如果communication link很拥堵，TCP不管交付需要多长时间都会等待把东西交付给对方，但是很多应用不希望延迟message传送，并且可以容忍一些数据丢失，这个时候TCP模型就不是很适合
	2. 无需链接简历。TCP在开始传输数据之前要经过三次握手，UDP缺不需要任何准备就可以传输出具，因此UDP不会引入建立链接的赤焰。 http适用的是TCP，dns适用的是UDP，http使用TCP是因为对于巨有文本数据的网页来说，可靠性只至关重要的。
	3. 无连接状态。TCP需要在端系统中维护连接状态，
	4. 分组首部开销小：每个TCP报文段都有20个字节的header cost, UDP 仅有8字节

-
-
- 可靠数据传输协议：reliable data transfer protocol.这是network最重要的topic之一，有点难啃，待会儿回来。
-
-
-
-
- 面向链接的传输：TCP
- TCP是传输层的一种协议，而且是面向链接的(connection-oriented)这是因为在应用进程发送数据之前，两个进程之间必须先相互handshake，也就是互相发送预备报文，确保数据传输的参数。handshake作为TCP链接的一部分，会厨师换很多TCP的状态变量。
-
- TCP 的这种链接完全保留在两个端系统当中，不是存在于中间状态，比如和路由器和链路交换机就是完全无关的，中间的状态会对TCP链接完全视而不见，它们看到的是数据报，不是链接。
-
- TCP链接提供的是全双工服务(full duplex service)如果一台主机上的进程A与另台主机进程上的B存在一条TCP链接，那么应用层的数据可以从进程B流向进程A，也可以从进程A流向进程B。TCP链接也总是点对点的，point to point,再一次发送中，点对多的数据发送方式对TCP来说是不可能的。
-
- TCP链接怎么建立？发起进程的进程叫做client progress, 另一个进程叫做server progress, client首先要告诉client的运输层，他想和服务器进程建立一条链接，
- clientSocket.connect((serverName, serverPort)),client上的TCP此时和服务器上的TCP建立了一条连接，client想server传输一个TCP message， server再回复一个message， client再回复一个message,前两个报文段不承载data，也就是不包含应用层数据，第三个报文段可以承载有效数据，这种链接的建立过程被叫做：三次握手three-way handshake
-
- TCP链接建立之后，两个应用进程之间就可以相互发送数据了。socket,就是运输层和网络层之间的那个门，client进程通过socket传递数据流，通过这个门之后，TCP会把数据存放到“send buffer”里面，接下来TCP会从缓存中取出数据传输到server,每次取出的数据受限于最大报文段长度(maximum segment size) MSS,
-
- 从上述讨论可以得知，TCP链接的组成包括：一台主机上的缓存、变量和进程链接的套接字，另一台主机上的另一组缓存、变量和进程链接的套接字。
-
- TCP如何建立可靠数据传输，之后再啃，有点难。[重要topic]
-
-
-
- 流量控制:
- 与TCP相连的任何一台主机中都有sender buffer, TCP 为它的应用程序提供了流量控制服务，flow control service,以消除client让server内存溢出的事情，流量控制因此是一个速度匹配服务，让发送方的发送速率和接收方的读取速率相匹配，具体的读不下去了
-
- TCP链接管理，之后看
-
- TCP拥塞控制，之后看
-
-
